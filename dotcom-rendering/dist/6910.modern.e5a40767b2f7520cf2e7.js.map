{"version":3,"file":"6910.modern.e5a40767b2f7520cf2e7.js","mappings":"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","sources":["webpack://@guardian/dotcom-rendering/./src/lib/articleCount.ts","webpack://@guardian/dotcom-rendering/./src/web/lib/braze/forceBrazeMessage.ts","webpack://@guardian/dotcom-rendering/./src/web/lib/braze/taylorReport.ts","webpack://@guardian/dotcom-rendering/./src/web/lib/contributions.ts","webpack://@guardian/dotcom-rendering/./src/web/lib/dailyArticleCount.ts","webpack://@guardian/dotcom-rendering/./src/web/lib/getIdapiUserData.ts","webpack://@guardian/dotcom-rendering/./src/web/lib/messagePicker.ts","webpack://@guardian/dotcom-rendering/./src/web/lib/setAutomat.ts","webpack://@guardian/dotcom-rendering/./src/web/lib/hasCurrentBrazeUser.ts","webpack://@guardian/dotcom-rendering/./src/web/lib/getBrazeUuid.ts","webpack://@guardian/dotcom-rendering/./src/web/lib/braze/hasRequiredConsents.ts","webpack://@guardian/dotcom-rendering/./src/web/lib/braze/checkBrazeDependencies.ts","webpack://@guardian/dotcom-rendering/./src/web/lib/braze/initialiseAppboy.ts","webpack://@guardian/dotcom-rendering/./src/web/lib/braze/buildBrazeMessaging.ts","webpack://@guardian/dotcom-rendering/./src/web/lib/useBraze.ts","webpack://@guardian/dotcom-rendering/./src/web/lib/useIsInView.ts","webpack://@guardian/dotcom-rendering/./src/web/lib/useOnce.ts"],"sourcesContent":["import { storage } from '@guardian/libs';\nimport {\n\tgetWeeklyArticleHistory,\n\tincrementWeeklyArticleCount,\n} from '@guardian/support-dotcom-components';\nimport type { WeeklyArticleHistory } from '@guardian/support-dotcom-components/dist/dotcom/src/types';\nimport { useEffect, useState } from 'react';\nimport { hasOptedOutOfArticleCount } from '../web/lib/contributions';\nimport type { DailyArticleHistory } from '../web/lib/dailyArticleCount';\nimport {\n\tgetDailyArticleCount,\n\tincrementDailyArticleCount,\n} from '../web/lib/dailyArticleCount';\n\nexport interface ArticleCounts {\n\tweeklyArticleHistory: WeeklyArticleHistory;\n\tdailyArticleHistory: DailyArticleHistory;\n}\n\n// We should monitor this function call to ensure it only happens within an\n// article pages when other pages are supported by DCR.\nexport const getArticleCounts = async (\n\tpageId: string,\n\tkeywordIds: string,\n): Promise<ArticleCounts | undefined> => {\n\tif (await hasOptedOutOfArticleCount()) return undefined;\n\n\t// hasOptedOut needs to be done before we check if articleCount is set in the window\n\t// This is because a potential race condition where one invocation of getArticleCounts\n\t// is waiting for hasOptedOut another invocation might receive it and increment the article count.\n\tif (!window.guardian.weeklyArticleCount) {\n\t\tincrementWeeklyArticleCount(\n\t\t\tstorage.local,\n\t\t\tpageId,\n\t\t\tkeywordIds.split(','),\n\t\t);\n\n\t\twindow.guardian.weeklyArticleCount = getWeeklyArticleHistory(\n\t\t\tstorage.local,\n\t\t);\n\t}\n\tif (!window.guardian.dailyArticleCount) {\n\t\tincrementDailyArticleCount();\n\t\twindow.guardian.dailyArticleCount = getDailyArticleCount();\n\t}\n\n\treturn {\n\t\tweeklyArticleHistory: window.guardian.weeklyArticleCount ?? [],\n\t\tdailyArticleHistory: window.guardian.dailyArticleCount ?? [],\n\t};\n};\n\nexport const useArticleCounts = (\n\tpageId: string,\n\tkeywordIds: string,\n): ArticleCounts | undefined | 'Pending' => {\n\tconst [articleCounts, setArticleCounts] = useState<\n\t\tArticleCounts | undefined | 'Pending'\n\t>('Pending');\n\n\tuseEffect(() => {\n\t\tgetArticleCounts(pageId, keywordIds)\n\t\t\t.then(setArticleCounts)\n\t\t\t.catch(() => setArticleCounts(undefined));\n\t}, [pageId, keywordIds]);\n\n\treturn articleCounts;\n};\n","const FORCE_BRAZE_ALLOWLIST = [\n\t'preview.gutools.co.uk',\n\t'preview.code.dev-gutools.co.uk',\n\tprocess.env.HOSTNAME ?? 'localhost',\n\t'm.thegulocal.com',\n];\n\ntype Meta = {\n\tdataFromBraze: {\n\t\t[key: string]: string;\n\t};\n\tlogImpressionWithBraze: () => void;\n\tlogButtonClickWithBraze: (id: number) => void;\n};\n\nexport const getBrazeMetaFromUrlFragment = (): Meta | null => {\n\tif (window.location.hash) {\n\t\t// This is intended for use on development domains for preview purposes.\n\t\t// It won't run in PROD.\n\n\t\tconst key = 'force-braze-message';\n\n\t\tconst hashString = window.location.hash;\n\n\t\tif (hashString.includes(key)) {\n\t\t\tif (!FORCE_BRAZE_ALLOWLIST.includes(window.location.hostname)) {\n\t\t\t\tconsole.log(`${key} is not supported on this domain`);\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst forcedMessage = hashString.slice(\n\t\t\t\thashString.indexOf(`${key}=`) + key.length + 1,\n\t\t\t\thashString.length,\n\t\t\t);\n\n\t\t\ttry {\n\t\t\t\tconst dataFromBraze = JSON.parse(\n\t\t\t\t\tdecodeURIComponent(forcedMessage),\n\t\t\t\t);\n\n\t\t\t\treturn {\n\t\t\t\t\tdataFromBraze,\n\t\t\t\t\tlogImpressionWithBraze: () => {},\n\t\t\t\t\tlogButtonClickWithBraze: () => {},\n\t\t\t\t};\n\t\t\t} catch (e) {\n\t\t\t\tconst error = e as Error;\n\t\t\t\t// Parsing failed. Log a message and fall through.\n\n\t\t\t\tconsole.log(`There was an error with ${key}: `, error.message);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn null;\n};\n","import { TagType } from '../../../types/tag';\n\nconst tagId = 'news/series/cotton-capital';\n\nexport const suppressForTaylorReport = (tags: TagType[]): boolean =>\n\twindow.guardian.config.switches.brazeTaylorReport === true &&\n\t!tags.find((tag) => tag.id === tagId);\n","import { onConsentChange } from '@guardian/consent-management-platform';\nimport { getCookie } from '@guardian/libs';\nimport type { HeaderPayload } from '@guardian/support-dotcom-components/dist/dotcom/src/types';\nimport { useState } from 'react';\nimport type { FEArticleType } from '../../types/frontend';\nimport type { IdApiUserData } from './getIdapiUserData';\nimport { getIdApiUserData } from './getIdapiUserData';\nimport { useOnce } from './useOnce';\n\n// User Atributes API cookies (dropped on sign-in)\nexport const HIDE_SUPPORT_MESSAGING_COOKIE = 'gu_hide_support_messaging';\nexport const RECURRING_CONTRIBUTOR_COOKIE = 'gu_recurring_contributor';\nexport const ONE_OFF_CONTRIBUTION_DATE_COOKIE = 'gu_one_off_contribution_date';\nexport const OPT_OUT_OF_ARTICLE_COUNT_COOKIE = 'gu_article_count_opt_out';\n\n// Support Frontend cookies (dropped when contribution is made)\nexport const SUPPORT_RECURRING_CONTRIBUTOR_MONTHLY_COOKIE =\n\t'gu.contributions.recurring.contrib-timestamp.Monthly';\nexport const SUPPORT_RECURRING_CONTRIBUTOR_ANNUAL_COOKIE =\n\t'gu.contributions.recurring.contrib-timestamp.Annual';\nexport const SUPPORT_ONE_OFF_CONTRIBUTION_COOKIE =\n\t'gu.contributions.contrib-timestamp';\n\n//  Local storage keys\nconst DAILY_ARTICLE_COUNT_KEY = 'gu.history.dailyArticleCount';\nconst WEEKLY_ARTICLE_COUNT_KEY = 'gu.history.weeklyArticleCount';\nexport const NO_RR_BANNER_TIMESTAMP_KEY = 'gu.noRRBannerTimestamp'; // timestamp of when we were last told not to show a RR banner\n\n// See https://github.com/guardian/support-dotcom-components/blob/main/module-versions.md\nexport const MODULES_VERSION = 'v3';\n\n// Cookie set by the User Attributes API upon signing in.\n// Value computed server-side and looks at all of the user's active products,\n// including but not limited to recurring & one-off contributions,\n// paper & digital subscriptions, as well as user tiers (GU supporters/staff/partners/patrons).\n// https://github.com/guardian/members-data-api/blob/3a72dc00b9389968d91e5930686aaf34d8040c52/membership-attribute-service/app/models/Attributes.scala\nconst shouldShowSupportMessaging = (): boolean => {\n\tconst hideSupportMessaging =\n\t\tgetCookie({ name: HIDE_SUPPORT_MESSAGING_COOKIE }) === 'true';\n\n\treturn !hideSupportMessaging;\n};\n\n// Determine if user is a recurring contributor by checking if they are signed in\n// AND have at least one of the relevant cookies.\n// We need to look at both User Attributes and Frontend Support cookies\n// as the former might not reflect the latest contributor status, since it's set upon signing in.\n// Frontend Support cookies are set when a contribution is made.\nexport const isRecurringContributor = (isSignedIn: boolean): boolean => {\n\t// Attributes cookie - we want this to have a specific value\n\tconst isRecurringContributorFromAttrs =\n\t\tgetCookie({ name: RECURRING_CONTRIBUTOR_COOKIE }) === 'true';\n\n\t// Support cookies - we only care whether these exist\n\tconst hasMonthlyContributionCookie =\n\t\tgetCookie({\n\t\t\tname: SUPPORT_RECURRING_CONTRIBUTOR_MONTHLY_COOKIE,\n\t\t\tshouldMemoize: true,\n\t\t}) !== null;\n\tconst hasAnnualContributionCookie =\n\t\tgetCookie({\n\t\t\tname: SUPPORT_RECURRING_CONTRIBUTOR_ANNUAL_COOKIE,\n\t\t\tshouldMemoize: true,\n\t\t}) !== null;\n\n\treturn (\n\t\tisSignedIn &&\n\t\t(isRecurringContributorFromAttrs ||\n\t\t\thasMonthlyContributionCookie ||\n\t\t\thasAnnualContributionCookie)\n\t);\n};\n\n// looks at attribute and support cookies\n// ONE_OFF_CONTRIBUTION_DATE_COOKIE (attributes cookie, when loggin in)\n// SUPPORT_ONE_OFF_CONTRIBUTION_COOKIE (support cookie, when making one-off contribution)\n// Get the date of the latest one-off contribution by looking at the two relevant cookies\n// and returning a Unix epoch string of the latest date found.\nexport const getLastOneOffContributionTimestamp = (): number | undefined => {\n\t// Attributes cookie - expects YYYY-MM-DD\n\tconst contributionDateFromAttributes = getCookie({\n\t\tname: ONE_OFF_CONTRIBUTION_DATE_COOKIE,\n\t});\n\n\t// Support cookies - expects Unix epoch\n\tconst contributionDateFromSupport = getCookie({\n\t\tname: SUPPORT_ONE_OFF_CONTRIBUTION_COOKIE,\n\t});\n\n\tif (!contributionDateFromAttributes && !contributionDateFromSupport) {\n\t\treturn undefined;\n\t}\n\n\t// Parse dates into common format so they can be compared\n\tconst parsedDateFromAttributes = contributionDateFromAttributes\n\t\t? Date.parse(contributionDateFromAttributes)\n\t\t: 0;\n\tconst parsedDateFromSupport = contributionDateFromSupport\n\t\t? parseInt(contributionDateFromSupport, 10)\n\t\t: 0;\n\n\t// Return most recent date\n\t// Condition only passed if 'parsedDateFromAttributes' is NOT NaN\n\tif (parsedDateFromAttributes > parsedDateFromSupport) {\n\t\treturn parsedDateFromAttributes;\n\t}\n\n\treturn parsedDateFromSupport || undefined; // This guards against 'parsedDateFromSupport' being NaN\n};\n\nexport const getLastOneOffContributionDate = (): string | undefined => {\n\tconst timestamp = getLastOneOffContributionTimestamp();\n\n\tif (timestamp === undefined) {\n\t\treturn undefined;\n\t}\n\n\tconst date = new Date(timestamp);\n\tconst year = date.getFullYear();\n\tconst month = (date.getMonth() + 1).toString().padStart(2, '0');\n\tconst day = date.getDate().toString().padStart(2, '0');\n\n\treturn `${year}-${month}-${day}`;\n};\n\nconst dateDiffDays = (from: number, to: number): number => {\n\tconst oneDayMs = 1000 * 60 * 60 * 24;\n\tconst diffMs = to - from;\n\treturn Math.floor(diffMs / oneDayMs);\n};\n\nconst AskPauseDays = 90;\n\nexport const isRecentOneOffContributor = (): boolean => {\n\tconst lastContributionDate = getLastOneOffContributionTimestamp();\n\tif (lastContributionDate !== undefined) {\n\t\tconst now = Date.now();\n\t\treturn dateDiffDays(lastContributionDate, now) <= AskPauseDays;\n\t}\n\n\treturn false;\n};\n\nexport const shouldHideSupportMessaging = (isSignedIn = false): boolean =>\n\t!shouldShowSupportMessaging() ||\n\tisRecurringContributor(isSignedIn) ||\n\tisRecentOneOffContributor();\n\nexport const REQUIRED_CONSENTS_FOR_ARTICLE_COUNT = [1, 3, 7];\nconst REQUIRED_CONSENTS_FOR_BROWSER_ID = [1, 3, 5, 7];\n\nexport const hasArticleCountOptOutCookie = (): boolean =>\n\tgetCookie({ name: OPT_OUT_OF_ARTICLE_COUNT_COOKIE }) !== null;\n\nconst removeArticleCountsFromLocalStorage = () => {\n\twindow.localStorage.removeItem(DAILY_ARTICLE_COUNT_KEY);\n\twindow.localStorage.removeItem(WEEKLY_ARTICLE_COUNT_KEY);\n};\n\nexport const hasCmpConsentForArticleCount = (): Promise<boolean> => {\n\treturn new Promise((resolve) => {\n\t\tif (getCookie({ name: 'gu-cmp-disabled', shouldMemoize: true })) {\n\t\t\tresolve(true);\n\t\t}\n\t\tonConsentChange(({ ccpa, tcfv2, aus }) => {\n\t\t\tif (ccpa || aus) {\n\t\t\t\tresolve(true);\n\t\t\t} else if (tcfv2) {\n\t\t\t\tconst hasRequiredConsents =\n\t\t\t\t\tREQUIRED_CONSENTS_FOR_ARTICLE_COUNT.every(\n\t\t\t\t\t\t(consent) => tcfv2.consents[consent],\n\t\t\t\t\t);\n\n\t\t\t\tif (!hasRequiredConsents) {\n\t\t\t\t\tremoveArticleCountsFromLocalStorage();\n\t\t\t\t}\n\t\t\t\tresolve(hasRequiredConsents);\n\t\t\t}\n\t\t});\n\t});\n};\n\nexport const hasOptedOutOfArticleCount = async (): Promise<boolean> => {\n\tconst hasCmpConsent = await hasCmpConsentForArticleCount();\n\treturn !hasCmpConsent || hasArticleCountOptOutCookie();\n};\n\n// A hook to find out if a user has opted out of article counting\nexport const useHasOptedOutOfArticleCount = (): boolean | 'Pending' => {\n\tconst [hasOptedOut, setHasOptedOut] = useState<boolean | 'Pending'>(\n\t\t'Pending',\n\t);\n\n\tuseOnce(() => {\n\t\thasOptedOutOfArticleCount()\n\t\t\t.then(setHasOptedOut)\n\t\t\t.catch(() => setHasOptedOut(true));\n\t}, []);\n\n\treturn hasOptedOut;\n};\n\nexport const hasCmpConsentForBrowserId = (): Promise<boolean> =>\n\tnew Promise((resolve) => {\n\t\tif (getCookie({ name: 'gu-cmp-disabled', shouldMemoize: true })) {\n\t\t\tresolve(true);\n\t\t}\n\t\tonConsentChange(({ ccpa, tcfv2, aus }) => {\n\t\t\tif (ccpa || aus) {\n\t\t\t\tresolve(true);\n\t\t\t} else if (tcfv2) {\n\t\t\t\tconst hasRequiredConsents =\n\t\t\t\t\tREQUIRED_CONSENTS_FOR_BROWSER_ID.every(\n\t\t\t\t\t\t(consent) => tcfv2.consents[consent],\n\t\t\t\t\t);\n\t\t\t\tresolve(hasRequiredConsents);\n\t\t\t}\n\t\t});\n\t});\n\nconst twentyMins = 20 * 60000;\nexport const withinLocalNoBannerCachePeriod = (): boolean => {\n\tconst item = window.localStorage.getItem(NO_RR_BANNER_TIMESTAMP_KEY);\n\tif (item && !Number.isNaN(parseInt(item, 10))) {\n\t\tconst withinCachePeriod = parseInt(item, 10) + twentyMins > Date.now();\n\t\tif (!withinCachePeriod) {\n\t\t\t// Expired\n\t\t\twindow.localStorage.removeItem(NO_RR_BANNER_TIMESTAMP_KEY);\n\t\t}\n\t\treturn withinCachePeriod;\n\t}\n\treturn false;\n};\n\nexport const setLocalNoBannerCachePeriod = (): void =>\n\twindow.localStorage.setItem(NO_RR_BANNER_TIMESTAMP_KEY, `${Date.now()}`);\n\nconst getEmail = (ajaxUrl: string): Promise<string | undefined> => {\n\treturn getIdApiUserData(ajaxUrl)\n\t\t.then((data: IdApiUserData) => data.user?.primaryEmailAddress)\n\t\t.catch((error) => {\n\t\t\twindow.guardian.modules.sentry.reportError(error, 'getEmail');\n\t\t\treturn undefined;\n\t\t});\n};\n\nexport const lazyFetchEmailWithTimeout =\n\t(idapiUrl: string): (() => Promise<string | null>) =>\n\t() => {\n\t\treturn new Promise((resolve) => {\n\t\t\tsetTimeout(() => resolve(null), 1000);\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-floating-promises\n\t\t\tgetEmail(idapiUrl).then((email) => {\n\t\t\t\tif (email) {\n\t\t\t\t\tresolve(email);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(null);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t};\n\nexport const getContributionsServiceUrl = (article: FEArticleType): string =>\n\tprocess.env.SDC_URL ?? article.contributionsServiceUrl;\n\ntype PurchaseInfo = HeaderPayload['targeting']['purchaseInfo'];\nexport const getPurchaseInfo = (): PurchaseInfo => {\n\tconst purchaseInfoRaw = getCookie({\n\t\tname: 'GU_CO_COMPLETE',\n\t\tshouldMemoize: true,\n\t});\n\n\tif (!purchaseInfoRaw) {\n\t\treturn undefined;\n\t}\n\n\tlet purchaseInfo: PurchaseInfo;\n\n\ttry {\n\t\tpurchaseInfo = JSON.parse(decodeURIComponent(purchaseInfoRaw));\n\t} catch {} // eslint-disable-line no-empty -- silently handle error\n\n\treturn purchaseInfo;\n};\n","export interface DailyArticle {\n\tday: number;\n\tcount: number;\n}\n\nexport type DailyArticleHistory = Array<DailyArticle>;\n\n// in localStorage, has format {\"value\":[{\"day\":18459,\"count\":1},{\"day\":18457,\"count\":1},{\"day\":18446,\"count\":1}]} to match frontend\ninterface DailyArticleCountLocalStorage {\n\tvalue: DailyArticleHistory;\n}\n\nexport const DailyArticleCountKey = 'gu.history.dailyArticleCount';\n\n// Returns undefined if no daily article count in local storage\nexport const getDailyArticleCount = (): DailyArticleHistory | undefined => {\n\tconst dailyCount = localStorage.getItem(DailyArticleCountKey);\n\n\tif (!dailyCount) {\n\t\treturn undefined;\n\t}\n\n\ttry {\n\t\tconst { value }: DailyArticleCountLocalStorage = JSON.parse(dailyCount);\n\n\t\t// check if value parsed correctly\n\t\tif (!value.length) {\n\t\t\tthrow new Error('Invalid gu.history.dailyArticleCount value');\n\t\t}\n\n\t\treturn value;\n\t} catch (e) {\n\t\t// error parsing the string, so remove the key\n\t\tlocalStorage.removeItem(DailyArticleCountKey);\n\t\treturn undefined;\n\t}\n};\n\nexport const getToday = (): number => Math.floor(Date.now() / 86_400_000);\n\nexport const incrementDailyArticleCount = (): void => {\n\t// get the daily article count from local storage\n\tconst dailyArticleCount = getDailyArticleCount() ?? [];\n\n\t// calculate days since unix epoch for today date\n\tconst today = getToday();\n\n\t// check if latest day is today and increment if so\n\tif (dailyArticleCount[0]?.day === today) {\n\t\tdailyArticleCount[0].count += 1;\n\t} else {\n\t\t// else set new day\n\t\tdailyArticleCount.unshift({ day: today, count: 1 });\n\n\t\t// remove any days older than 60\n\t\tconst cutOff = today - 60;\n\n\t\tconst firstOldDayIndex = dailyArticleCount.findIndex(\n\t\t\t(dailyCount) => dailyCount.day && dailyCount.day < cutOff,\n\t\t);\n\n\t\tif (firstOldDayIndex > 0) {\n\t\t\tdailyArticleCount.splice(firstOldDayIndex);\n\t\t}\n\t}\n\n\t// set the latest article count\n\tlocalStorage.setItem(\n\t\tDailyArticleCountKey,\n\t\tJSON.stringify({\n\t\t\tvalue: dailyArticleCount,\n\t\t} as DailyArticleCountLocalStorage),\n\t);\n};\n","import { joinUrl } from '@guardian/libs';\n\nexport interface IdApiUserData {\n\tuser?: {\n\t\tprimaryEmailAddress?: string;\n\t\tprivateFields?: {\n\t\t\tbrazeUuid?: string;\n\t\t};\n\t};\n}\n\nexport interface IdApiUserIdentifiers {\n\tid: string;\n\tbrazeUuid: string;\n\tpuzzleId: string;\n\tgoogleTagId: string;\n}\n\nfunction checkForErrors(response: Response) {\n\tif (!response.ok) {\n\t\tthrow Error(\n\t\t\tresponse.statusText ||\n\t\t\t\t`getIdApiUserData | An api call returned HTTP status ${response.status}`,\n\t\t);\n\t}\n\treturn response;\n}\n\nconst callApi = (url: string) => {\n\treturn fetch(url, {\n\t\tcredentials: 'include',\n\t})\n\t\t.then(checkForErrors)\n\t\t.then((response) => response.json());\n};\n\nconst cache: {\n\tidapiUserMeResponse?: Promise<IdApiUserData>;\n\tidapiUserIdentifiersResponse?: Promise<IdApiUserIdentifiers>;\n} = {};\n\nexport const getIdApiUserData = (ajaxUrl: string): Promise<IdApiUserData> => {\n\tif (!cache.idapiUserMeResponse) {\n\t\tconst url = joinUrl(ajaxUrl, 'user/me');\n\t\tcache.idapiUserMeResponse = callApi(url);\n\t}\n\treturn cache.idapiUserMeResponse;\n};\n\nexport const getIdapiUserIdentifiers = (\n\tajaxUrl: string,\n): Promise<IdApiUserIdentifiers> => {\n\tif (!cache.idapiUserIdentifiersResponse) {\n\t\tconst url = joinUrl(ajaxUrl, 'user/me/identifiers');\n\t\tcache.idapiUserIdentifiersResponse = callApi(url);\n\t}\n\treturn cache.idapiUserIdentifiersResponse;\n};\n","import { initPerf } from '../browser/initPerf';\nimport { record } from '../browser/ophan/ophan';\n\nexport type MaybeFC = React.FC | null;\ntype ShowMessage<T> = (meta: T) => MaybeFC;\n\ninterface ShouldShow<T> {\n\tshow: true;\n\tmeta: T;\n}\ninterface ShouldNotShow {\n\tshow: false;\n}\nexport type CanShowResult<T> = ShouldShow<T> | ShouldNotShow;\n\ntype Candidate<T> = {\n\tid: string;\n\tshow: ShowMessage<T>;\n\tcanShow: () => Promise<CanShowResult<T>>;\n};\n\nexport type CandidateConfig<T> = {\n\tcandidate: Candidate<T>;\n\ttimeoutMillis: number | null;\n\treportTiming?: boolean;\n};\n\ntype CandidateConfigWithTimeout<T> = CandidateConfig<T> & {\n\tcancelTimeout: () => void;\n};\n\nexport type SlotConfig = {\n\tcandidates: CandidateConfig<any>[];\n\tname: string;\n};\n\nconst recordMessageTimeoutInOphan = (candidateId: string, slotName: string) =>\n\trecord({\n\t\tcomponent: `${slotName}-picker-timeout-dcr`,\n\t\tvalue: candidateId,\n\t});\n\nconst timeoutify = <T>(\n\tcandidateConfig: CandidateConfig<T>,\n\tslotName: string,\n): CandidateConfigWithTimeout<T> => {\n\tlet timer: number | undefined;\n\n\tconst canShow = (): Promise<CanShowResult<T>> =>\n\t\tnew Promise((resolve) => {\n\t\t\tconst perfName = `messagePicker-canShow-${candidateConfig.candidate.id}`;\n\t\t\tconst canShowTiming = initPerf(perfName);\n\t\t\tcanShowTiming.start();\n\n\t\t\tif (candidateConfig.timeoutMillis !== null) {\n\t\t\t\ttimer = window.setTimeout(() => {\n\t\t\t\t\trecordMessageTimeoutInOphan(\n\t\t\t\t\t\tcandidateConfig.candidate.id,\n\t\t\t\t\t\tslotName,\n\t\t\t\t\t);\n\t\t\t\t\tresolve({ show: false });\n\t\t\t\t}, candidateConfig.timeoutMillis);\n\t\t\t}\n\n\t\t\tcandidateConfig.candidate\n\t\t\t\t.canShow()\n\t\t\t\t.then((result) => {\n\t\t\t\t\tresolve(result);\n\n\t\t\t\t\tconst canShowTimeTaken = canShowTiming.end();\n\n\t\t\t\t\tif (candidateConfig.reportTiming) {\n\t\t\t\t\t\trecord({\n\t\t\t\t\t\t\tcomponent: perfName,\n\t\t\t\t\t\t\tvalue: canShowTimeTaken,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.catch((e) =>\n\t\t\t\t\tconsole.error(`timeoutify candidate - error: ${String(e)}`),\n\t\t\t\t);\n\t\t});\n\n\tconst cancelTimeout = () => timer !== undefined && clearTimeout(timer);\n\n\treturn {\n\t\t...candidateConfig,\n\t\tcandidate: {\n\t\t\t...candidateConfig.candidate,\n\t\t\tcanShow,\n\t\t},\n\t\tcancelTimeout,\n\t};\n};\n\nconst clearAllTimeouts = (messages: CandidateConfigWithTimeout<any>[]) =>\n\tmessages.map((m) => m.cancelTimeout());\n\nconst defaultShow = () => null;\n\ninterface PendingMessage<T> {\n\tcandidateConfig: CandidateConfigWithTimeout<T>;\n\tcanShow: Promise<CanShowResult<T>>;\n}\n\ninterface WinningMessage<T> {\n\tmeta: T;\n\tcandidate: Candidate<T>;\n}\n\nexport const pickMessage = ({\n\tcandidates,\n\tname,\n}: SlotConfig): Promise<() => MaybeFC> =>\n\tnew Promise((resolve) => {\n\t\tconst candidateConfigsWithTimeout = candidates.map((c) =>\n\t\t\ttimeoutify(c, name),\n\t\t);\n\t\tconst results: PendingMessage<any>[] = candidateConfigsWithTimeout.map(\n\t\t\t(candidateConfig) => ({\n\t\t\t\tcandidateConfig,\n\t\t\t\tcanShow: candidateConfig.candidate.canShow(),\n\t\t\t}),\n\t\t);\n\n\t\tconst winnerResult = results.reduce<\n\t\t\tPromise<WinningMessage<any> | null>\n\t\t>(async (winningMessageSoFar, { candidateConfig, canShow }) => {\n\t\t\tif (await winningMessageSoFar) {\n\t\t\t\treturn winningMessageSoFar;\n\t\t\t}\n\n\t\t\tconst result = await canShow;\n\t\t\tcandidateConfig.cancelTimeout();\n\t\t\tif (result.show) {\n\t\t\t\treturn {\n\t\t\t\t\tcandidate: candidateConfig.candidate,\n\t\t\t\t\tmeta: result.meta,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn winningMessageSoFar;\n\t\t}, Promise.resolve(null));\n\n\t\twinnerResult\n\t\t\t.then((winner) => {\n\t\t\t\tclearAllTimeouts(candidateConfigsWithTimeout);\n\n\t\t\t\tif (winner === null) {\n\t\t\t\t\tresolve(defaultShow);\n\t\t\t\t} else {\n\t\t\t\t\tconst { candidate, meta } = winner;\n\t\t\t\t\tresolve(() => candidate.show(meta));\n\t\t\t\t}\n\t\t\t})\n\t\t\t.catch((e) =>\n\t\t\t\tconsole.error(`pickMessage winner - error: ${String(e)}`),\n\t\t\t);\n\t});\n","import * as emotionReact from '@emotion/react';\nimport * as emotionReactJsxRuntime from '@emotion/react/jsx-runtime';\nimport React from 'react';\n\nlet hasAutomatBeenSet = false;\n\nexport const setAutomat = (): void => {\n\tif (!hasAutomatBeenSet) {\n\t\twindow.guardian.automat = {\n\t\t\temotionReact,\n\t\t\temotionReactJsxRuntime,\n\t\t\treact: React,\n\t\t};\n\t\thasAutomatBeenSet = true;\n\t}\n};\n","const KEY = 'gu.brazeUserSet';\n\nconst hasCurrentBrazeUser = (): boolean => {\n\treturn localStorage.getItem(KEY) === 'true';\n};\n\nconst setHasCurrentBrazeUser = (): void => {\n\tlocalStorage.setItem(KEY, 'true');\n};\n\nconst clearHasCurrentBrazeUser = (): void => {\n\tlocalStorage.removeItem(KEY);\n};\n\nexport {\n\thasCurrentBrazeUser,\n\tsetHasCurrentBrazeUser,\n\tclearHasCurrentBrazeUser,\n};\n","import type { IdApiUserIdentifiers } from './getIdapiUserData';\nimport { getIdapiUserIdentifiers } from './getIdapiUserData';\n\nexport const getBrazeUuid = async (ajaxUrl: string): Promise<string | void> => {\n\treturn getIdapiUserIdentifiers(ajaxUrl)\n\t\t.then((data: IdApiUserIdentifiers) => data.brazeUuid)\n\t\t.catch((error) => {\n\t\t\twindow.guardian.modules.sentry.reportError(error, 'getBrazeUuid');\n\t\t});\n};\n","import {\n\tgetConsentFor,\n\tonConsentChange,\n} from '@guardian/consent-management-platform';\n\nconst hasRequiredConsents = (): Promise<boolean> =>\n\tnew Promise((resolve, reject) => {\n\t\tonConsentChange((state) => {\n\t\t\ttry {\n\t\t\t\tresolve(getConsentFor('braze', state));\n\t\t\t} catch (e) {\n\t\t\t\treject(e);\n\t\t\t}\n\t\t});\n\t});\n\nexport { hasRequiredConsents };\n","import { getBrazeUuid } from '../getBrazeUuid';\nimport { hasRequiredConsents } from './hasRequiredConsents';\n\ntype SuccessResult = {\n\tisSuccessful: true;\n\tdata: ResultData;\n};\n\ntype FailureResult = {\n\tisSuccessful: false;\n\tfailure: {\n\t\tfield: string;\n\t\tdata: any;\n\t};\n\tdata: ResultData;\n};\n\ntype DependenciesResult = SuccessResult | FailureResult;\n\ntype ResultData = { [key: string]: string | boolean };\n\ntype DependencyResult = {\n\tname: string;\n\tvalue: Promise<string | boolean | null | undefined | void>;\n};\nconst buildFailureResponse = (name: string, value: any, data: ResultData) => ({\n\tisSuccessful: false,\n\tfailure: {\n\t\tfield: name,\n\t\tdata: value,\n\t},\n\tdata,\n});\n\nconst buildDependencies = (\n\tisSignedIn: boolean,\n\tidApiUrl: string,\n): DependencyResult[] => {\n\treturn [\n\t\t{\n\t\t\tname: 'apiKey',\n\t\t\tvalue: Promise.resolve(window.guardian.config.page.brazeApiKey),\n\t\t},\n\t\t{\n\t\t\tname: 'brazeSwitch',\n\t\t\tvalue: Promise.resolve(window.guardian.config.switches.brazeSwitch),\n\t\t},\n\t\t{\n\t\t\tname: 'brazeUuid',\n\t\t\tvalue: isSignedIn ? getBrazeUuid(idApiUrl) : Promise.resolve(null),\n\t\t},\n\t\t{\n\t\t\tname: 'consent',\n\t\t\tvalue: hasRequiredConsents(),\n\t\t},\n\t\t{\n\t\t\tname: 'isNotPaidContent',\n\t\t\tvalue: Promise.resolve(!window.guardian.config.page.isPaidContent),\n\t\t},\n\t];\n};\n\nconst checkBrazeDependencies = async (\n\tisSignedIn: boolean,\n\tidApiUrl: string,\n): Promise<DependenciesResult> => {\n\tconst dependencies = buildDependencies(isSignedIn, idApiUrl);\n\n\tconst data: ResultData = {};\n\n\t// I think we could possibly clean this up a bit when we can use\n\t// Promise.allSettled reliably (it's not available in our current Node\n\t// version and polyfill.io doesn't have a polyfill yet).\n\tfor (const { name, value } of dependencies) {\n\t\ttry {\n\t\t\tconst result = await value;\n\n\t\t\t// eslint-disable-next-line @typescript-eslint/strict-boolean-expressions -- TODO: Complex types, look into this further\n\t\t\tif (result) {\n\t\t\t\tdata[name] = result;\n\t\t\t} else {\n\t\t\t\treturn buildFailureResponse(name, result, data);\n\t\t\t}\n\t\t} catch (e) {\n\t\t\treturn buildFailureResponse(\n\t\t\t\tname,\n\t\t\t\te instanceof Error ? e.message : e,\n\t\t\t\tdata,\n\t\t\t);\n\t\t}\n\t}\n\n\treturn {\n\t\tisSuccessful: true,\n\t\tdata,\n\t};\n};\n\nexport { checkBrazeDependencies };\n","import type appboy from '@braze/web-sdk-core';\nimport { log } from '@guardian/libs';\n\nconst SDK_OPTIONS: appboy.InitializationOptions = {\n\tenableLogging: true,\n\tnoCookies: true,\n\tbaseUrl: 'https://sdk.fra-01.braze.eu/api/v3',\n\tsessionTimeoutInSeconds: 1,\n\tminimumIntervalBetweenTriggerActionsInSeconds: 0,\n\tdevicePropertyAllowlist: [],\n};\n\nconst initialiseAppboy = async (apiKey: string): Promise<typeof appboy> => {\n\tconst importedAppboy = (await import(\n\t\t/* webpackChunkName: \"braze-web-sdk-core\" */ '@braze/web-sdk-core'\n\t)) as unknown as typeof appboy;\n\n\timportedAppboy.setLogger((message) => log('tx', message));\n\timportedAppboy.initialize(apiKey, SDK_OPTIONS);\n\n\treturn importedAppboy;\n};\n\nconst getInitialisedAppboy = (() => {\n\tlet cache: Promise<typeof appboy>;\n\n\treturn (apiKey: string): Promise<typeof appboy> => {\n\t\tif (cache === undefined) {\n\t\t\tcache = initialiseAppboy(apiKey);\n\t\t}\n\n\t\treturn cache;\n\t};\n})();\n\nexport { getInitialisedAppboy };\n","import type {\n\tBrazeCardsInterface,\n\tBrazeMessagesInterface,\n} from '@guardian/braze-components/logic';\nimport {\n\tBrazeCards,\n\tBrazeMessages,\n\tLocalMessageCache,\n\tNullBrazeCards,\n\tNullBrazeMessages,\n} from '@guardian/braze-components/logic';\nimport { getCookie, log, storage } from '@guardian/libs';\nimport { initPerf } from '../../browser/initPerf';\nimport { record } from '../../browser/ophan/ophan';\nimport {\n\tclearHasCurrentBrazeUser,\n\thasCurrentBrazeUser,\n\tsetHasCurrentBrazeUser,\n} from '../hasCurrentBrazeUser';\nimport { checkBrazeDependencies } from './checkBrazeDependencies';\nimport { getInitialisedAppboy } from './initialiseAppboy';\n\nconst maybeWipeUserData = async (\n\tapiKey?: string,\n\tbrazeUuid?: null | string,\n\tconsent?: boolean,\n\tbrazeSwitch?: boolean,\n): Promise<void> => {\n\tconst hasCurrentBrazeUserValue = hasCurrentBrazeUser();\n\tconst userHasLoggedOut = !brazeUuid && hasCurrentBrazeUserValue;\n\tconst userHasRemovedConsent = !consent && hasCurrentBrazeUserValue;\n\tconst brazeHasBeenDisabled = !brazeSwitch && hasCurrentBrazeUserValue;\n\n\tif (userHasLoggedOut || userHasRemovedConsent || brazeHasBeenDisabled) {\n\t\ttry {\n\t\t\tif (apiKey) {\n\t\t\t\tconst appboy = await getInitialisedAppboy(apiKey);\n\t\t\t\tappboy.wipeData();\n\t\t\t}\n\t\t\tLocalMessageCache.clear();\n\t\t\tclearHasCurrentBrazeUser();\n\t\t} catch (error) {\n\t\t\twindow.guardian.modules.sentry.reportError(\n\t\t\t\t// @ts-expect-error\n\t\t\t\terror,\n\t\t\t\t'braze-maybeWipeUserData',\n\t\t\t);\n\t\t}\n\t}\n};\n\nexport const buildBrazeMessaging = async (\n\tidApiUrl: string,\n): Promise<{\n\tbrazeMessages: BrazeMessagesInterface;\n\tbrazeCards: BrazeCardsInterface;\n}> => {\n\tif (!storage.local.isAvailable()) {\n\t\t// we require local storage for using any message channel so that we know\n\t\t// when to clear up user data from the device on logout\n\t\treturn {\n\t\t\tbrazeMessages: new NullBrazeMessages(),\n\t\t\tbrazeCards: new NullBrazeCards(),\n\t\t};\n\t}\n\n\tconst isSignedIn = !!getCookie({ name: 'GU_U', shouldMemoize: true });\n\n\tconst dependenciesResult = await checkBrazeDependencies(\n\t\tisSignedIn,\n\t\tidApiUrl,\n\t);\n\n\tif (!dependenciesResult.isSuccessful) {\n\t\tconst { failure, data } = dependenciesResult;\n\n\t\tlog(\n\t\t\t'tx',\n\t\t\t`Not attempting to show Braze messages. Dependency ${\n\t\t\t\tfailure.field\n\t\t\t} failed with ${String(failure.data)}.`,\n\t\t);\n\n\t\tawait maybeWipeUserData(\n\t\t\tdata.apiKey as string | undefined,\n\t\t\tdata.brazeUuid as string | null | undefined,\n\t\t\tdata.consent as boolean | undefined,\n\t\t\tdata.brazeSwitch as boolean | undefined,\n\t\t);\n\n\t\treturn {\n\t\t\tbrazeMessages: new NullBrazeMessages(),\n\t\t\tbrazeCards: new NullBrazeCards(),\n\t\t};\n\t}\n\n\ttry {\n\t\tconst sdkLoadTiming = initPerf('braze-sdk-load');\n\t\tsdkLoadTiming.start();\n\n\t\tconst appboy = await getInitialisedAppboy(\n\t\t\tdependenciesResult.data.apiKey as string,\n\t\t);\n\n\t\tconst sdkLoadTimeTaken = sdkLoadTiming.end();\n\t\trecord({\n\t\t\tcomponent: 'braze-sdk-load-timing',\n\t\t\tvalue: sdkLoadTimeTaken,\n\t\t});\n\n\t\tconst errorHandler = (error: Error, desc: string) => {\n\t\t\twindow.guardian.modules.sentry.reportError(error, desc);\n\t\t};\n\n\t\tsetHasCurrentBrazeUser();\n\t\tappboy.changeUser(dependenciesResult.data.brazeUuid as string);\n\t\tappboy.openSession();\n\n\t\tconst brazeCards = window.guardian.config.switches.brazeContentCards\n\t\t\t? new BrazeCards(appboy, errorHandler)\n\t\t\t: new NullBrazeCards();\n\t\tconst brazeMessages = new BrazeMessages(\n\t\t\tappboy,\n\t\t\tLocalMessageCache,\n\t\t\terrorHandler,\n\t\t);\n\t\treturn { brazeMessages, brazeCards };\n\t} catch {\n\t\treturn {\n\t\t\tbrazeMessages: new NullBrazeMessages(),\n\t\t\tbrazeCards: new NullBrazeCards(),\n\t\t};\n\t}\n};\n","import type {\n\tBrazeCardsInterface,\n\tBrazeMessagesInterface,\n} from '@guardian/braze-components/logic';\nimport {\n\tNullBrazeCards,\n\tNullBrazeMessages,\n} from '@guardian/braze-components/logic';\nimport useSWRImmutable from 'swr/immutable';\nimport { buildBrazeMessaging } from './braze/buildBrazeMessaging';\n\n/**\n * Returns brazeMessaging as BrazeMessagesInterface and BrazeCardsInterface\n *\n * BrazeMessages is used to show single-impression messages (like ad impressions).\n * In contrast, BrazeCards can provide persistent user notifications.\n *\n * We're using useSWRImmutable to ensure this call is only made once\n * [doc]: https://swr.vercel.app/docs/revalidation#disable-automatic-revalidations\n */\nexport const useBraze = (\n\tidApiUrl: string,\n): {\n\tbrazeMessages: BrazeMessagesInterface | undefined;\n\tbrazeCards: BrazeCardsInterface | undefined;\n} => {\n\tconst { data, error } = useSWRImmutable('braze-message', () =>\n\t\tbuildBrazeMessaging(idApiUrl),\n\t);\n\n\tif (error) {\n\t\treturn {\n\t\t\tbrazeMessages: new NullBrazeMessages(),\n\t\t\tbrazeCards: new NullBrazeCards(),\n\t\t};\n\t}\n\n\treturn {\n\t\tbrazeMessages: data?.brazeMessages,\n\t\tbrazeCards: data?.brazeCards,\n\t};\n};\n","import libDebounce from 'lodash.debounce';\nimport { useEffect, useRef, useState } from 'react';\n\n/**\n * Custom hook around the `IntersectionObserver`.\n *\n * @param options\n * @param {boolean} [options.debouce] If `true`, debounce triggers by 200ms.\n * By default, trigger instantaneously. Enabling debouncing ensures the target\n * element intersects for at least 200ms before the callback is executed\n * @param {boolean} [options.repeat] If `true`, trigger the hook on\n * all intersections. By default, only trigger on the first intersection.\n * @param {boolean} [options.node] Set the initial node, if known.\n * @returns a tuple containing [isInView, setNode];\n */\nconst useIsInView = (\n\toptions: IntersectionObserverInit & {\n\t\tdebounce?: true;\n\t\trepeat?: true;\n\t\tnode?: HTMLElement;\n\t},\n): [boolean, React.Dispatch<React.SetStateAction<HTMLElement | null>>] => {\n\tconst [isInView, setIsInView] = useState<boolean>(false);\n\tconst [node, setNode] = useState<HTMLElement | null>(options.node ?? null);\n\n\tconst observer = useRef<IntersectionObserver | null>(null);\n\n\tconst intersectionFn: IntersectionObserverCallback = ([entry]) => {\n\t\tif (!entry) return;\n\n\t\tif (entry.isIntersecting) {\n\t\t\tsetIsInView(true);\n\t\t} else if (options.repeat) {\n\t\t\tsetIsInView(false);\n\t\t}\n\t};\n\tconst intersectionCallback = options.debounce\n\t\t? libDebounce(intersectionFn, 200)\n\t\t: intersectionFn;\n\n\tuseEffect(() => {\n\t\t// TODO: can we remove this? It’s now always cleaned up\n\t\tif (observer.current) {\n\t\t\tobserver.current.disconnect();\n\t\t}\n\n\t\t// eslint-disable-next-line @typescript-eslint/strict-boolean-expressions, @typescript-eslint/no-unnecessary-condition -- Safety for browser support\n\t\tif (window.IntersectionObserver) {\n\t\t\tobserver.current = new window.IntersectionObserver(\n\t\t\t\tintersectionCallback,\n\t\t\t\toptions,\n\t\t\t);\n\n\t\t\tif (node) {\n\t\t\t\tobserver.current.observe(node);\n\t\t\t}\n\t\t}\n\n\t\treturn () => observer.current?.disconnect();\n\t}, [node, options, intersectionCallback]);\n\n\treturn [isInView, setNode];\n};\n\nexport { useIsInView };\n","import { useEffect, useState } from 'react';\n\n/**\n * Ensures that the given task is only run once and only after all items in waitFor are defined\n * @param {Function} task - The task to execute once\n * @param {Array} waitFor - An array of variables that must be defined before the task is executed\n * */\nexport const useOnce = (task: () => void, waitFor: unknown[]): void => {\n\tconst [alreadyRun, setAlreadyRun] = useState(false);\n\tconst isReady = waitFor.every((dep) => dep !== undefined);\n\tuseEffect(() => {\n\t\tif (!alreadyRun && isReady) {\n\t\t\ttask();\n\t\t\tsetAlreadyRun(true);\n\t\t}\n\t}, [alreadyRun, isReady, task]);\n};\n"],"names":["getArticleCounts","async","pageId","keywordIds","window","hasOptedOutOfArticleCount","guardian","weeklyArticleCount","incrementWeeklyArticleCount","storage","split","getWeeklyArticleHistory","dailyArticleCount","incrementDailyArticleCount","getDailyArticleCount","weeklyArticleHistory","dailyArticleHistory","useArticleCounts","articleCounts","setArticleCounts","useState","useEffect","then","catch","undefined","FORCE_BRAZE_ALLOWLIST","getBrazeMetaFromUrlFragment","location","hash","key","hashString","includes","hostname","console","log","forcedMessage","slice","indexOf","length","dataFromBraze","JSON","parse","decodeURIComponent","logImpressionWithBraze","logButtonClickWithBraze","e","error","message","suppressForTaylorReport","tags","config","switches","brazeTaylorReport","find","tag","id","HIDE_SUPPORT_MESSAGING_COOKIE","RECURRING_CONTRIBUTOR_COOKIE","SUPPORT_RECURRING_CONTRIBUTOR_MONTHLY_COOKIE","SUPPORT_RECURRING_CONTRIBUTOR_ANNUAL_COOKIE","SUPPORT_ONE_OFF_CONTRIBUTION_COOKIE","NO_RR_BANNER_TIMESTAMP_KEY","MODULES_VERSION","shouldShowSupportMessaging","getCookie","name","isRecurringContributor","isSignedIn","isRecurringContributorFromAttrs","hasMonthlyContributionCookie","shouldMemoize","hasAnnualContributionCookie","getLastOneOffContributionTimestamp","contributionDateFromAttributes","contributionDateFromSupport","parsedDateFromAttributes","Date","parsedDateFromSupport","parseInt","getLastOneOffContributionDate","timestamp","date","year","getFullYear","month","getMonth","toString","padStart","day","getDate","isRecentOneOffContributor","lastContributionDate","from","to","diffMs","now","Math","floor","dateDiffDays","shouldHideSupportMessaging","REQUIRED_CONSENTS_FOR_ARTICLE_COUNT","REQUIRED_CONSENTS_FOR_BROWSER_ID","hasCmpConsentForArticleCount","Promise","resolve","onConsentChange","ccpa","tcfv2","aus","hasRequiredConsents","every","consent","consents","localStorage","removeItem","useHasOptedOutOfArticleCount","hasOptedOut","setHasOptedOut","useOnce","hasCmpConsentForBrowserId","withinLocalNoBannerCachePeriod","item","getItem","Number","isNaN","withinCachePeriod","setLocalNoBannerCachePeriod","setItem","lazyFetchEmailWithTimeout","idapiUrl","ajaxUrl","setTimeout","getIdApiUserData","data","user","primaryEmailAddress","modules","sentry","reportError","email","getPurchaseInfo","purchaseInfoRaw","purchaseInfo","DailyArticleCountKey","dailyCount","value","Error","getToday","today","count","unshift","cutOff","firstOldDayIndex","findIndex","splice","stringify","checkForErrors","response","ok","statusText","status","callApi","url","fetch","credentials","json","cache","idapiUserMeResponse","joinUrl","getIdapiUserIdentifiers","idapiUserIdentifiersResponse","defaultShow","pickMessage","candidates","candidateConfigsWithTimeout","map","c","candidateConfig","slotName","timer","candidate","canShow","perfName","canShowTiming","initPerf","start","timeoutMillis","candidateId","record","component","recordMessageTimeoutInOphan","show","result","canShowTimeTaken","end","reportTiming","String","cancelTimeout","clearTimeout","timeoutify","winnerResult","reduce","winningMessageSoFar","meta","winner","m","hasAutomatBeenSet","setAutomat","automat","emotionReact","emotionReactJsxRuntime","react","React","KEY","getBrazeUuid","brazeUuid","buildFailureResponse","isSuccessful","failure","field","SDK_OPTIONS","enableLogging","noCookies","baseUrl","sessionTimeoutInSeconds","minimumIntervalBetweenTriggerActionsInSeconds","devicePropertyAllowlist","getInitialisedAppboy","apiKey","importedAppboy","setLogger","initialize","initialiseAppboy","buildBrazeMessaging","idApiUrl","brazeMessages","NullBrazeMessages","brazeCards","NullBrazeCards","dependenciesResult","dependencies","page","brazeApiKey","brazeSwitch","reject","state","getConsentFor","isPaidContent","buildDependencies","checkBrazeDependencies","hasCurrentBrazeUserValue","wipeData","LocalMessageCache","maybeWipeUserData","sdkLoadTiming","appboy","sdkLoadTimeTaken","errorHandler","desc","changeUser","openSession","brazeContentCards","BrazeCards","BrazeMessages","useBraze","useSWRImmutable","useIsInView","options","isInView","setIsInView","node","setNode","observer","useRef","intersectionFn","entry","isIntersecting","repeat","intersectionCallback","debounce","libDebounce","current","disconnect","IntersectionObserver","observe","task","waitFor","alreadyRun","setAlreadyRun","isReady","dep"],"sourceRoot":""}