{"version":3,"file":"TweetBlockComponent-importable.legacy.bc53fb06f418224a14ca.js","mappings":"uIAiBA,SAASA,EAAWC,EAAKC,EAAMC,GAC3B,OAAOF,EAAIE,QAAQ,IAAIC,OAJ3B,SAAsBH,GAClB,OAAOA,EAAIE,QAAQ,4BAA6B,OACpD,CAEkCE,CAAaH,GAAO,KAAMC,EAC5D,C,iBACO,IAOMG,EAAe,SAACC,GACzB,IAAIC,EAAYD,EAIhB,OAHAC,EAAYR,EAAWQ,EAAW,SAAU,WAC5CA,EAAYR,EAAWQ,EAAW,YAAa,WACnCR,EAAWQ,EAAW,aAAc,WAEpD,C,wHC3BMC,GAAcC,EAAAA,EAAAA,KAAG,0DAEDC,EAAAA,GAAAA,UAAgB,iEAKlCC,EAAAA,GAAAA,QAAY,mGAwCHC,EAAsB,SAAH,GAAqB,IAAfC,EAAO,EAAPA,QAMlC,OALAC,EAAAA,EAAAA,YAAU,YAdI,SAACD,GACf,IAAME,EAAiBC,SAASC,eAAe,mBAAD,OAAoBJ,EAAQK,YACpEC,EAAQH,SAASI,cAAc,oBAAD,OAAqBP,EAAQK,UAAS,6BACtEH,GAAkBI,GAA0B,oBAAVE,QAIlCF,EAAMG,UAAUC,IAAI,iBACpBF,MAAMG,OAAM,SAACC,GACTA,EAAQC,QAAQC,KAAKZ,EACzB,IAER,CAKQa,CAAUf,EACd,GAAG,CAACA,KACIgB,EAAAA,EAAAA,KAAK,MAAO,CAAEC,GAAG,mBAAD,OAAqBjB,EAAQK,WAAaT,IAAKD,EAAauB,wBAAyB,CAAEC,QAAQ3B,EAAAA,EAAAA,GAAaQ,EAAQoB,QAChJ,C","sources":["webpack://@guardian/dotcom-rendering/./src/lib/escapeData.tsx","webpack://@guardian/dotcom-rendering/./src/web/components/TweetBlockComponent.importable.tsx"],"sourcesContent":["/**\n * Create an escapedData string that can be safely placed inside script tags on the page\n *\n * The level of sanitisation here is limited to escaping script tags to prevent\n * errors when embedded html string contain their own script tags.\n *\n * See: https://www.w3.org/TR/html52/semantics-scripting.html#restrictions-for-contents-of-script-elements\n *\n *  > The easiest and safest way to avoid the rather strange restrictions described in this section is to\n *  > always escape \"&lt;!--\" as \"&lt;\\!--\", \"&lt;script\" as \"&lt;\\script\", and \"&lt;/script\" as \"&lt;\\/script\"\n *\n * TODO: This could be extended\n */\n// See: https://stackoverflow.com/a/1144788\nfunction escapeRegExp(str) {\n    return str.replace(/([.*+?^=!:${}()|[\\]/\\\\])/g, '\\\\$1');\n}\nfunction replaceAll(str, find, replace) {\n    return str.replace(new RegExp(escapeRegExp(find), 'g'), replace);\n}\nexport const escapeData = (data) => {\n    let escaped = data;\n    escaped = replaceAll(escaped, '<!--', '<\\\\!--');\n    escaped = replaceAll(escaped, '<script', '<\\\\script');\n    escaped = replaceAll(escaped, '</script', '<\\\\/script');\n    return escaped;\n};\nexport const unescapeData = (data) => {\n    let unescaped = data;\n    unescaped = replaceAll(unescaped, '<\\\\!--', '<!--');\n    unescaped = replaceAll(unescaped, '<\\\\script', '<script');\n    unescaped = replaceAll(unescaped, '<\\\\/script', '</script');\n    return unescaped;\n};\n","import { jsx as _jsx } from \"@emotion/react/jsx-runtime\";\nimport { css } from '@emotion/react';\nimport { body, border } from '@guardian/source-foundations';\nimport { useEffect } from 'react';\nimport { unescapeData } from '../../lib/escapeData';\n// fallback styling for when JS is disabled\nconst noJSStyling = css `\n\t.nojs-tweet:not(.nojs-tweet-rendered) {\n\t\tborder: 1px solid ${border.secondary};\n\t\tborder-radius: 4px;\n\t\tpadding: 20px;\n\t\twidth: 100%;\n\t\tmargin-bottom: 16px;\n\t\t${body.small()};\n\t}\n\n\t.nojs-tweet iframe {\n\t\t/* Unfortunately due to how Twitter embeds work setting !important is the only way to overwrite tweet CSS */\n\t\t/* stylelint-disable-next-line declaration-no-important */\n\t\twidth: 100% !important;\n\t}\n\n\t.nojs-tweet p {\n\t\tpadding-bottom: 10px;\n\t}\n\n\ta {\n\t\t/* stylelint-disable-next-line color-no-hex */\n\t\tcolor: #2b7bb9;\n\t}\n`;\n/**\n * loadTweet takes the nojs default version of a Twitter tweet embed\n * and enhances it using Twitter's platform api script\n *\n * This code should only execute if switches.enhanceTweets is true (see\n * renderElements)\n *\n * @param element TweetBlockElement - The tweet element we want to enhance\n */\nconst loadTweet = (element) => {\n    const tweetContainer = document.getElementById(`tweet-container-${element.elementId}`);\n    const tweet = document.querySelector(`#tweet-container-${element.elementId} > blockquote.nojs-tweet`);\n    if (tweetContainer && tweet && typeof twttr !== 'undefined') {\n        // We need this classname to exist as this is what Twitter uses\n        // to find the tweet on the page. We *remove* this class in\n        // enhanceTweets()\n        tweet.classList.add('twitter-tweet');\n        twttr.ready((twitter) => {\n            twitter.widgets.load(tweetContainer);\n        });\n    }\n};\nexport const TweetBlockComponent = ({ element }) => {\n    useEffect(() => {\n        // This code only runs if this component is hydrated, which\n        // only happens if the enhanceTweets switch is on\n        loadTweet(element);\n    }, [element]);\n    return (_jsx(\"div\", { id: `tweet-container-${element.elementId}`, css: noJSStyling, dangerouslySetInnerHTML: { __html: unescapeData(element.html) } }));\n};\n"],"names":["replaceAll","str","find","replace","RegExp","escapeRegExp","unescapeData","data","unescaped","noJSStyling","css","border","body","TweetBlockComponent","element","useEffect","tweetContainer","document","getElementById","elementId","tweet","querySelector","twttr","classList","add","ready","twitter","widgets","load","loadTweet","_jsx","id","dangerouslySetInnerHTML","__html","html"],"sourceRoot":""}